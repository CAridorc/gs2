<html>
<head>
<title>GS2 documentation</title>
</head>
<body>
<h1>GS2 documentation</h1>
<h2>What is GS2?</h2>
<p>GS2 is a stack-based, concatenative programming language with functional influences, inspired by <a href="http://www.golfscript.com/">GolfScript</a> and <a href="http://jsoftware.com/">J</a>. Its primary purpose is doing well at <a href="https://en.wikipedia.org/wiki/Code_golf">code golf</a> contests; it achieves this by supplying many built-in commands and syntactical shortcuts that are each only one byte long.</p>
<p>Programming in GS2 is conceptually similar to programming in GolfScript or similar languages: the stack initially contains a string representing standard input, and its contents are printed to standard output when the program is finished.</p>

<h2>Values</h2>
GS2 values are integers, blocks, or lists. Blocks contain unevaluated code, representing "functions", like in GolfScript. There is no dedicated string type: strings are just lists of integers.

<h2>Tokens</h2>
<p>Throughout this document mnemonics are listed next to some token names; these
are compatible with the included gs2c utility.</p>

<p>Special tokens are:</p>
<dl>
<dt>$01 $xx</dt>
<dd>Push unsigned byte $xx to stack.</dd>
<dt>$02 $yy $xx</dt>
<dd>Push signed short $xxyy to stack.</dd>
<dt>$03 $zz $yy $xx $ww</dt>
<dd>Push signed short $wwxxyyzz to stack.</dd>
<dt>$04 <em>ss</em> $zz</dt>
<dd>Push string(s) to stack. <em>ss</em> is separated by $07; the action performed is decided by the string end byte $zz, which is one of:
<ul>
  <li>$05: push strings to stack, sequentially</li>
  <li>$06: push strings to stack in array</li>
  <li>$9b: sprintf (pops format from <em>ss</em>, pops fitting number of items from stack, pushes formatted string)</li>
  <li>$9c: regex match (pops regex from <em>ss</em>, pops string from stack, pushes 1 on match, else 0)</li>
  <li>$9d: regex replace (pops replacement string from <em>ss</em>, pops regex from <em>ss</em>, pops string from stack and pushes re.sub result)</li>
  <li>$9e: regex find (like $9c, but calls re.findall)</li>
  <li>$9f: regex split (like $9c, but calls re.split)</li>
</ul>
The regexes used by these operations may be prefixed by special characters to set a special variable <em>c</em>: by default it is 0, prefixing the regex by $5D sets it to 1, prefixing it by $7D $xx sets it to xx. <em>c</em> affects the operations as follows:
<ul>
  <li>$9c: match whole string if c &gt; 0</li>
  <li>$9d: perform at most c substitutions (unlimited if c = 0)</li>
  <li>$9e: find first matching substring only if c &gt; 0 (else array of matching substrings)</li>
  <li>$9f: perform at most c splits (unlimited if c = 0)</li>
</ul>
Furthermore, if the first character of a program is $04, it may be omitted; an unmatched string closing token will automatically be paired up.
</dd>
<dt>$07 $cc</dt>
<dd>Push single-character string "$cc" to stack.</dd>
<dt>$08</dt>
<dd>Opens a block.</dd>
<dt>$09</dt>
<dd>Closes a block.</dd>
<dt>%111xxyyy (hex values $e0 through $fb)</dt>
<dd>Wraps last y+1 values into a block. x is the final token (what do we do with this block?): 0=nop, 1=map (0x34), 2=filter (0x35), 3=apply on top 2 elements (0x38)</dd>
<dt>$xx $fc (dm1, dump-map1)</dt>
<dd>Map single token inside lists. Short for $08 $90 $xx $09 $34.</dd>
<dt>$xx $fd (df1, dump-filter1)</dt>
<dd>Filter single token inside lists. Short for $08 $90 $xx $09 $35.</dd>
<dt>$fe (m:)</dt>
<dd>Open rest-of-program map block.</dd>
<dt>$ff (f:)</dt>
<dd>Open rest-of-program filter block.</dd>
</dl>

The following single-byte tokens have special meaning at the start of a program:
<dl>
<dt>$30 (line-mode)</dt>
<dd>Line mode: [program] &rarr; [lines, map program, unlines]</dd>
<dt>$31 (word-mode)</dt>
<dd>Word mode: [program] &rarr; [words, map program, unwords]</dd>
<dt>$32 (line-mode-skip-first)</dt>
<dd>Like $30, but ignore first line.</dd>
</dl>

All other tokens are simple operations that pop values from the stack and push results back.

<h2>Constants</h2>
The following single-byte tokens push constants to the stack:
<table border="1">
<tr><th>Byte</th><th>Constant</th></tr>
<tr><td>$0a (new-line)</td><td>[$0a]</td>
<tr><td>$0b (empty-list)</td><td>[]</td>
<tr><td>$0c (empty-block)</td><td>{}</td>
<tr><td>$0d (space)</td><td>[$20]</td>
<tr><td>$10 - $1a</td><td>0 - 10</td>
<tr><td>$1b</td><td>100</td>
<tr><td>$1c</td><td>1000</td>
<tr><td>$1d</td><td>16</td>
<tr><td>$1e</td><td>64</td>
<tr><td>$1f</td><td>256</td>
</table>

<h2>Functions</h2>
<dl>
<dt>$0e (make-array)</dt>
<dd>Pop n, then pop n elements and push them back in an array.</dd>
<dt>$20 (negate, reverse, eval)</dt>
<dd>Negates numbers, reverses lists, evaluates blocks.</dd>
<dt>$21 (bnot, head)</dt>
<dd>Bitwise-negates numbers, extracts first element from lists.</dd>
<dt>$22 (not, tail)</dt>
<dd>Boolean negation for numbers, drops first element from lists.</dd>
<dt>$23 (abs, init)</dt>
<dd>Absolute value for numbers, drops last element from lists.</dd>
<dt>$24 (digits, last)</dt>
<dd>Push array of base 10 digits for numbers, extracts last element from lists.</dd>
<dt>$25 (random)</dt>
<dd>Push random.randint(0, x-1) for numbers x, chooses random element for lists.</dd>
<dt>$26 (dec, left-uncons)</dt>
<dd>Subtracts 1 from numbers, pushes tail and then head for lists.</dd>
<dt>$27 (inc, right-uncons)</dt>
<dd>Adds 1 to numbers, pushes init and then last for lists.</dd>
<dt>$28 (sign, min)</dt>
<dd>Pushes sign for numbers, minimum for lists.</dd>
<dt>$29 (thousand, max)</dt>
<dd>Multiplies numbers by 1000, maximum for lists.</dd>
<dt>$2a (double, lines)</dt>
<dd>Multiplies numbers by 2, splits over newlines for lists.</dd>
<dt>$2b (half, unlines)</dt>
<dd>Divides numbers by 2, joins with newlines for lists.</dd>
<dt>$2c (square, words)</dt>
<dd>Squares numbers, splits over space for lists.</dd>
<dt>$2d (sqrt, unwords)</dt>
<dd>Integer square root for numbers, joins with space for lists.</dd>
<dt>$2e (range, length)</dt>
<dd>Pushes [0..n-1] for numbers n, pushes length for lists.</dd>
<dt>$2f (range1, sort)</dt>
<dd>Pushes [1..n] for numbers n, sorts lists, sortBy for blocks.</dd>
<dt>$30 (add, cat, +)</dt>
<dd>Adds numbers, catenates lists/blocks.</dd>
<dt>$31 (sub, diff, -)</dt>
<dd>Subtracts numbers, set difference for lists.</dd>
<dt>$32 (mul, join, times, fold, *)</dt>
<dd>Multiplies numbers, repeats list+number, joins two lists, folds block.</dd>
<dt>$33 (div, chunks, split, each, /)</dt>
<dd>Divides numbers, chunksOf for list+number, splits two lists, applies block over each element of list.</dd>
<dt>$34 (mod, step, clean-split, map, %)</dt>
<dd>Modulo numbers, each nth element for list+number, splits two lists removing empty lists, maps block over list.</dd>
<dt>$35 (and, get, when, filter, &amp;)</dt>
<dd>Bitwise ands numbers, indexes for list+number, evals number+block only when underlying number is nonzero, filters for list+block.</dd>
Et cetera, et cetera, et cetera. You know what, just read the mnemonics in gs2.py and mess around with them. If you need to know anything ask me via <a href="mailto:0nooodl@gmail.com">mail</a> or IRC (I'm mauris in #anagol on freenode.)
</dl>

<h2>Example usage and gs2c</h2>
<p>The included gs2c.py script is an "assembler" that compiles a more readable representation of gs2 opcodes and constants. It reads mnemonics for gs2 functions from the source code of gs2.py itself! Let's write a simple program, compile it using gs2c.py, and run it.</p>

<p>A very simple golf challenge is the following: given a positive integer n on standard input, print a triangle of asterisks of size n:</p>
<pre>*
**
***
****
*****</pre>
<p>We read the number, then map a block over [1..n], turning each number into asterisks followed by a newline:</p>

<pre>read-num range1 m: "*" times new-line</pre>

<p>Then gs2c can compile this, and gs2 can run the resulting file:</p>

<pre>$ python gs2c.py &lt; stars &gt; compiled &amp;&amp; echo 7 | python gs2.py compiled
*
**
***
****
*****
******
*******</pre>

<p>Our solution is 7 bytes long: 56 2f fe 07 2a 32 0a. This is pretty good compared to GolfScript's 11.</p>
</body>
</html>